This is rs-rainflow.info, produced by makeinfo version 6.7 from
rs-rainflow.texi.

This is the reference manual for the 'rs-rainflow' library version
20180218.2240.

Copyright (C) 2015 Ralph Schleicher

Permission is granted to make and distribute verbatim copies of this
manual, provided the copyright notice and this permission notice are
preserved on all copies.
INFO-DIR-SECTION Libraries
START-INFO-DIR-ENTRY
* RS-Rainflow: (rs-rainflow).   Rainflow cycle counting.
END-INFO-DIR-ENTRY


File: rs-rainflow.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Rainflow Cycle Counting
***********************

This is the reference manual for the 'rs-rainflow' library version
20180218.2240.

Copyright (C) 2015 Ralph Schleicher

Permission is granted to make and distribute verbatim copies of this
manual, provided the copyright notice and this permission notice are
preserved on all copies.

* Menu:

* Introduction::
* User's Guide::
* API Reference::
* Examples::
* Symbol Index::
* Concept Index::
* References::


File: rs-rainflow.info,  Node: Introduction,  Next: User's Guide,  Prev: Top,  Up: Top

1 Introduction
**************

Rainflow cycle counting is a widely accepted method for transforming a
sequence of signal values into an equivalent sequence of cycles.  Each
cycle is a tuple with three values.  The first value is the signal
amplitude ŝ, i.e.  half the distance between the trough and peak signal
value.  The second value is the mean value s̄, i.e.  the arithmetic mean
of the trough and peak signal value.  The third value is the cycle count
n, i.e.  the number of alterations between the trough and peak signal
value.  The cycle count can be expressed as the number of full cycles or
the number of half cycles.

Cycle counting is mainly used in fatigue analysis.  A cumulative damage
model, e.g.  Miner's rule, is applied on the cycle counting sequence to
assess a part's fatigue life with the help of material S-N curves.
Beside that, cycle counting is also useful to derive fatigue, duty
cycle, or endurance spectra itself.


File: rs-rainflow.info,  Node: User's Guide,  Next: API Reference,  Prev: Introduction,  Up: Top

2 User's Guide
**************

The 'rs-rainflow' library contains functions to perform rainflow cycle
counting.  The implementation has several features:

   * The procedure is re-entrant(1), that means you can call it multiple
     times in a row until all input data, i.e.  the signal history, is
     processed.

   * Support for different signal data types.  You can switch the signal
     data type between consecutive invocations.

   * Intermediate values and holds are automatically removed from the
     signal history.

   * Support for alternative memory managers.

   * Support for different cycle representations.  You can choose
     between amplitude/mean, range/mean, and from/to cycle
     representation.  You can also enable signed cycles for the
     amplitude/mean and range/mean cycle representations so that you
     have no loss of information compared to the from/to cycle
     representation.

   * Support for signal labels so that you can analyse which signal
     values, i.e.  load cases, build the critical cycles, e.g.  those
     with the highest damages.

   * Cycles can be cached or shifted (consumed) according to your needs.

   * Cycles can be sorted and merged according to your needs.

N.b.: The 'rs-rainflow' library always counts half cycles.  You have to
divide the cycle count by two if you want to know the number of full
cycles.

* Menu:

* Instantiation::
* Execution::
* Customisation::
* Sorting Cycles::
* Rainflow Matrix::

   ---------- Footnotes ----------

   (1) But not thread safe.


File: rs-rainflow.info,  Node: Instantiation,  Next: Execution,  Prev: User's Guide,  Up: User's Guide

2.1 Instantiation
=================

You have to create a rainflow cycle counting object before you can start
counting cycles.  Calling the 'rs_rainflow_new' function is the standard
procedure to do so.

A rainflow cycle counting object has the opaque data type
'rs_rainflow_t'.  Therefore, you can only work with pointers to rainflow
cycle counting objects.  For example,

     rs_rainflow_t *OBJ = rs_rainflow_new ();

The 'rs_rainflow_new' function utilises the standard memory management
functions of the C library, i.e. 'malloc', 'realloc', and 'free'.  The
'rs_rainflow_alloc' function is another rainflow cycle counting object
creation function where you can specify alternative memory management
functions.

You usually call 'rs_rainflow_delete' when you are done with a rainflow
cycle counting object.  Then you call 'rs_rainflow_new' or
'rs_rainflow_alloc' if you need another rainflow cycle counting object.
The 'rs_rainflow_reset' convenience function has the same effect except
that the reference to the rainflow cycle counting object remains the
same.


File: rs-rainflow.info,  Node: Execution,  Next: Customisation,  Prev: Instantiation,  Up: User's Guide

2.2 Execution
=============

The 'rs_rainflow' function is the core procedure for counting cycles.
The result of rainflow cycle counting is a cycle counting sequence.  A
cycle counting sequence is an array of double precision floating-point
numbers where each row represents a cycle.  The first two elements of a
cycle are used for the cycle representation and the third element
contains the cycle count.

You can call the 'rs_rainflow_cycles' function to determine the current
length of the cycle counting sequence.  If cycles are available, then
you can shift (consume) cycles by calling the 'rs_rainflow_shift'
function.

Rainflow cycle counting ends when the 'rs_rainflow' function is called
with a non-zero fourth argument.  You can also call the
'rs_rainflow_finish' convenience function to terminate cycle counting.

When rainflow cycle counting is finished, you can still call the
'rs_rainflow_cycles' and 'rs_rainflow_shift' functions to consume the
remaining cycles.

An alternative method to access the cycle counting sequence is to call
the 'rs_rainflow_capture' function.  Calling this function makes you the
owner of the cycle counting sequence.  Therefore, this is only possible
if rainflow cycle counting is finished.


File: rs-rainflow.info,  Node: Customisation,  Next: Sorting Cycles,  Prev: Execution,  Up: User's Guide

2.3 Customisation
=================

The state of a rainflow cycle counting object controls the behaviour of
the 'rs_rainflow' function.  The default behaviour is as follows.

   * The signal history is expected to be an array of double precision
     floating-point numbers whose elements can be accessed sequentially.

   * Signal labels are disabled.

   * Cycles are represented by amplitude and mean value.

   * Similar consecutive cycles are merged by adding the individual
     cycle counts.

   * The cycle counting sequence is cached by the rainflow cycle
     counting object.

The rest of this section shows you how to adjust these settings to suite
your needs.

* Menu:

* Signal History::
* Signal Labels::
* Cycle Representation::
* Merging Cycles::
* Consuming Cycles::


File: rs-rainflow.info,  Node: Signal History,  Next: Signal Labels,  Prev: Customisation,  Up: Customisation

2.3.1 Signal History
--------------------

You can provide the signal history in two ways; as an array of numbers,
or via a user-defined call-back function.

2.3.1.1 Array of Numbers
........................

You can pass an array of numbers, i.e.  a pointer to the first array
element, as the second argument to the 'rs_rainflow' function.  The data
type of the array elements is defined by the
'rs_rainflow_set_signal_type' function.  The data type conversion from
the array element type to the internal format is performed by the
'rs_rainflow' function.  All numeric C data types are supported that
way.

Please note that you can switch the array element type between
consecutive invocations of the 'rs_rainflow' function.

2.3.1.2 User-defined Call-back Function
.......................................

If your signal history is not an array of numbers, then you can write a
user-defined call-back function and install it with the
'rs_rainflow_set_read_signals' function.  *Note Using Call-back
Functions::, for an example.


File: rs-rainflow.info,  Node: Signal Labels,  Next: Cycle Representation,  Prev: Signal History,  Up: Customisation

2.3.2 Signal Labels
-------------------

Signal labels can be used to assign an identifier to a signal value.
This information is traced and recorded in the cycle counting sequence
so that you can analyse which signal values were used to build a cycle.
Signals labels are enabled or disabled by calling the
'rs_rainflow_set_signal_label' function.

When signal labels are enabled, each cycle is a tuple with five
elements.  The first three elements have the usual meaning, i.e.  cycle
representation and cycle count, the fourth element is the signal label
of the _from_ signal value, and the fifth element is the signal label of
the _to_ signal value.  Although a cycle is defined as an array of
double precision floating-point numbers, any value that can be stored in
the eight bytes of a 'double' can be used as a signal label.

There are two types of signal labels; implicit signal labels and
explicit signal labels.

2.3.2.1 Implicit Signal Labels
..............................

Implicit signal labels are automatically assigned to a signal value by
the 'rs_rainflow' function.  The signal label is an integer(1) which is
incremented after each signal value.  Thus, the signal label is like a
linear index into the signal history.  The start index, i.e.  the signal
label of the first signal value, can be set via the
'rs_rainflow_set_signal_index' function.  The default start index is
zero.

Implicit signal labels only work with the built-in data types.  If you
install a user-defined signal history access function, then you have to
use explicit signal labels.

2.3.2.2 Explicit Signal Labels
..............................

Explicit signal labels have to be assigned in a user-defined signal
history access function (*note User-defined Call-back Function::).  That
means the call-back function has to copy the signal value and the signal
label.  For example, suppose the elements of a signal history are
defined as follows:

     struct sig
       {
         /* Signal value.  */
         float value;

         /* Signal label.  */
         char *label;
       };

With that the user-defined call-back function for reading elements from
the signal history could look like this:

     size_t
     read_signals (struct sig const *sig, double *buffer, size_t count)
     {
       size_t c;

       for (c = count; c > 0; --c, ++sig)
         {
           /* Copy signal value.  */
           *buffer++ = sig->value;

           /* Copy signal label.  */
           memcpy (buffer, &sig->label, sizeof (char *));
           ++buffer;
         }

       return count - c;
     }

To play save, you should check at the beginning of your program if
'sizeof (char *)' is not greater than 'sizeof (double)'.  It is no
problem if the inverse is true since argument BUFFER is initialised with
zeros.  See the 'rs_rainflow_set_read_signals' function for more details
about the calling conventions.

   ---------- Footnotes ----------

   (1) The maximum integer that you can store as a double precision
floating-point number without loss of precision is usually 2^{53}.  With
that you can record a signal at octuple-rate DSD, i.e.  22579.2 kHz, for
4617 days or 12.6 years before you run out of signal labels.


File: rs-rainflow.info,  Node: Cycle Representation,  Next: Merging Cycles,  Prev: Signal Labels,  Up: Customisation

2.3.3 Cycle Representation
--------------------------

A cycle is a tuple with three or five elements.  The first and second
element is the cycle representation.  The third element is the cycle
count, i.e.  the number of half cycles.  If signal labels are enabled,
then the fourth and fifth element are the from/to signal labels.  In C,
a cycle is an array of three or five double precision floating-point
numbers.

The 'rs-rainflow' library supports three different cycle
representations.  You can choose between amplitude/mean, range/mean, and
from/to cycle representation.  The cycle representation can be changed
via the 'rs_rainflow_set_cycle_style' function but this has to be done
before you start counting cycles.

2.3.3.1 Amplitude/Mean Cycle Representation
...........................................

Amplitude/mean cycle representation is the default cycle representation
of the 'rs-rainflow' library.  Thus, a cycle has the form {s_a, s_m, n,
t_1, t_2} where s_a is the signal amplitude, s_m is the signal mean, n
is the cycle count, and t_1 and t_2 are the optional from/to signal
labels.

The signal amplitude is unsigned by default.  That means you can
calculate the peak and trough signal value but you don't know the
direction of the cycle(1).  You can enable signed cycle representation
by calling the 'rs_rainflow_set_cycle_sign' function.  With that a
positive signal amplitude means that the _from_ signal value is less
than the _to_ signal value and a negative signal amplitude means that
the _from_ signal value is greater than the _to_ signal value.

2.3.3.2 Range/Mean Cycle Representation
.......................................

Range/mean cycle representation is like amplitude/mean cycle
representation except that the signal amplitude is replaced by the
signal range, i.e.  two times the signal amplitude.  Thus, a cycle has
the form {s_r, s_m, n, ...} where s_r is the signal range and s_m is the
signal mean.

2.3.3.3 From/To Cycle Representation
....................................

With from/to cycle representation a cycle has the form {s_1, s_2, n,
...} where s_1 and s_2 are the extrema values of the cycle in
chronological order.

   ---------- Footnotes ----------

   (1) It would be possible with the help of signal labels since signal
labels are always saved in chronological order of the signal values


File: rs-rainflow.info,  Node: Merging Cycles,  Next: Consuming Cycles,  Prev: Cycle Representation,  Up: Customisation

2.3.4 Merging Cycles
--------------------

Similar consecutive cycles are merged by adding the individual cycle
counts.  This optimisation reduces the length of the cycle counting
sequence without loosing any information.  Cycles are similar if the
signal values and the optional signal labels are equal and in the
correct chronological order.

For example, if a half cycle from s_1 to s_2 is directly followed by a
half cycle from s_2 to s_1, then this is equal to a full cycle from s_1
to s_2.  If another full cycle from s_1 to s_2 follows, then this is
equal to two full cycles from s_1 to s_2.

You can enable or disable this feature via the
'rs_rainflow_set_merge_cycles' function.  Merging cycles is enabled by
default.


File: rs-rainflow.info,  Node: Consuming Cycles,  Prev: Merging Cycles,  Up: Customisation

2.3.5 Consuming Cycles
----------------------

By default the cycle counting sequence is cached by the rainflow cycle
counting object.  The length of the cycle counting sequence is estimated
from the number of elements in the signal history.  See function
'rs_rainflow_set_length' for how to change the memory allocation
strategy for the cycle counting sequence.

You can call the 'rs_rainflow_cycles' function to determine the current
length of the cycle counting sequence.  If cycles are available, then
you can shift (consume) cycles by calling the 'rs_rainflow_shift'
function.

This explicit process can be automated by installing a user-defined
call-back function via the 'rs_rainflow_set_shift_cycle' function.  This
call-back function is invoked by the 'rs_rainflow' function whenever a
cycle can be added to the cycle counting sequence.  The benefit of this
method is that the cached cycle counting sequence does not grow no
matter how long the signal history is.  *Note Using Call-back
Functions:: for an example.


File: rs-rainflow.info,  Node: Sorting Cycles,  Next: Rainflow Matrix,  Prev: Customisation,  Up: User's Guide

2.4 Sorting Cycles
==================

After rainflow cycle counting has finished, you can sort the cycles of
the cached cycle counting sequence with the 'rs_rainflow_sort' function.
You have to write a user-defined cycle comparison function for sorting
cycles.  First you need a function to compare two floating-point
numbers, like this one:

     /* Compare the number A against B.  If A is considered greater than B, the return value is
        a positive number.  If A is considered less than B, the return value is a negative number.
        If the two numbers are equal, the return value is zero.  */
     int
     fcmp (double a, double b)
     {
       return (a > b) - (a < b);
     }

Now we can use the 'fcmp' function to compare two cycles.

     /* Compare the cycle A against B.  */
     int
     compare_cycles (double const *a, double const *b)
     {
       int diff;

       diff = fcmp (a[0], b[0]);
       if (diff != 0)
         return diff;

       return fcmp (a[1], b[1]);
     }

The 'compare_cycles' function can be used to sort cycles in either
ascending or descending order.  For the later, simply exchange the
arguments A and B.  With GNU C, you can also use the expression
'fcmp (a[0], b[0]) ? : fcmp (a[1], b[1])'.  Whether or not signal labels
are considered by the cycle comparison function is your choice.


File: rs-rainflow.info,  Node: Rainflow Matrix,  Prev: Sorting Cycles,  Up: User's Guide

2.5 Rainflow Matrix
===================

A rainflow matrix is also a kind of sorting but the two elements of the
cycle representation are always sorted in strictly monotonic increasing
order.  The cycle count of similar cycles is summed up.  Signal labels
are always ignored.  The name rainflow matrix comes from the fact that
the cycle representation can be considered as the row and column indices
into a two-dimensional array and the cycle count is the corresponding
matrix element.

You can create and destroy a rainflow matrix by calling the
'rs_rainflow_matrix_new' and 'rs_rainflow_matrix_delete' function
respectively.

Cycles are added to the rainflow matrix by calling the
'rs_rainflow_matrix_add' or 'rs_rainflow_matrix_add3' function.  Matrix
elements, i.e.  the cycle counts, are queried via the
'rs_rainflow_matrix_get' or 'rs_rainflow_matrix_get2' function.

You can query the range of a rainflow matrix dimension, i.e.  the
smallest and largest value of the corresponding element of the cycle
representation, with the 'rs_rainflow_matrix_limits' function.

The 'rs_rainflow_matrix_non_zero' function returns the number of
non-zero elements in a rainflow matrix.  You can apply a function on
each non-zero element by calling the 'rs_rainflow_matrix_map' function.

Cycles are usually binned before they are added to a rainflow matrix.
The 'rs_rainflow_round_amplitude_mean', 'rs_rainflow_round_range_mean',
and 'rs_rainflow_round_from_to' functions do this conservatively, i.e.
the peak signal value is rounded up (toward positive infinity) and the
trough signal value is rounded down (toward negative infinity).

Here is a simple cycle shift function (*note Consuming Cycles::) that
adds the cycle to a rainflow matrix.

     void
     shift_cycle (rs_rainflow_matrix_t *mat, double const *cycle)
     {
       double tem[3];

       memcpy (tem, cycle, 3 * sizeof (double));
       /* Signal values are binned to a multiple or 20 MPa.  Thus, the signal
          amplitude and signal mean are both binned to 10 MPa.  */
       rs_rainflow_round_amplitude_mean (tem, 20.0);
       rs_rainflow_matrix_add (mat, tem);
     }


File: rs-rainflow.info,  Node: API Reference,  Next: Examples,  Prev: User's Guide,  Up: Top

3 API Reference
***************

All symbols described in this chapter are defined in the header file
'rs-rainflow.h'.

* Menu:

* Data Types::
* Functions::
* Enumerated Constants::


File: rs-rainflow.info,  Node: Data Types,  Next: Functions,  Prev: API Reference,  Up: API Reference

3.1 Data Types
==============

 -- Data Type: rs_rainflow_t
     The data type of a rainflow cycle counting object.

     This is an opaque data type.  You only deal with pointers to
     rainflow cycle counting objects.

 -- Data Type: rs_rainflow_matrix_t
     The data type of a rainflow matrix object.

     This is an opaque data type.  You only deal with pointers to
     rainflow matrix objects.


File: rs-rainflow.info,  Node: Functions,  Next: Enumerated Constants,  Prev: Data Types,  Up: API Reference

3.2 Functions
=============

 -- Function: rs_rainflow_t * rs_rainflow_new (void)
     Create a rainflow cycle counting object.

     Return value is a pointer to a new rainflow cycle counting object.
     In case of an error, a null pointer is returned and 'errno' is set
     to describe the error.

 -- Function: rs_rainflow_t * rs_rainflow_alloc
          (void *(*MALLOC) (size_t), void *(*REALLOC) (void *, size_t),
          void (*FREE) (void *))
     Create a rainflow cycle counting object using an alternative memory
     manager.

        * First argument MALLOC is a function to allocate a block of
          memory.  The semantic of this function is the same as of the
          'malloc' function.  It is guaranteed that the argument to the
          MALLOC function is greater than zero.

        * Second argument REALLOC is a function to resize a block of
          memory allocated by the MALLOC function.  The semantic of this
          function is the same as of the 'realloc' function.  It is
          guaranteed that the first argument to the REALLOC function is
          not a null pointer and that the second argument is greater
          than zero.

        * Third argument FREE is a function to free a block of memory
          allocated by the MALLOC function.  The semantic of this
          function is the same as of the 'free' function.  It is
          guaranteed that the argument to the FREE function is not a
          null pointer.  If argument FREE is a null pointer, it is
          assumed that unused memory allocated via the MALLOC function
          is collected by the memory manager.

     Return value is a pointer to a new rainflow cycle counting object.
     In case of an error, a null pointer is returned and 'errno' is set
     to describe the error.  The following error conditions are defined
     for this function:

     'EINVAL'
          Argument MALLOC or REALLOC is a null pointer.

 -- Function: void rs_rainflow_delete (rs_rainflow_t *OBJ)
     Delete a rainflow cycle counting object.

        * Argument OBJ is a pointer to a rainflow cycle counting object.
          It is no error if argument OBJ is a null pointer.

     Deleting a rainflow cycle counting object means to unconditionally
     return any allocated memory back to the system including the object
     itself.  After that, all references to the rainflow cycle counting
     object are void.

 -- Function: int rs_rainflow_reset (rs_rainflow_t *OBJ)
     Reset a rainflow cycle counting object.

        * Argument OBJ is a pointer to a rainflow cycle counting object.

     The effect of this function is like calling 'rs_rainflow_delete'
     followed by a call to 'rs_rainflow_new' except that the rainflow
     cycle counting object itself and the associated memory management
     functions remain the same.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

 -- Function: int rs_rainflow (rs_rainflow_t *OBJ, void *SIG,
          size_t SIG_LEN, int FINISH)
     Perform rainflow cycle counting.

        * First argument OBJ is a pointer to a rainflow cycle counting
          object.

        * Second argument SIG is a pointer to the signal history.

        * Third argument SIG_LEN is the number of elements in the signal
          history.  A value of '(size_t) -1' means that the length of
          the signal history is undetermined, i.e.  the signal history
          has infinite length.

        * Fourth argument FINISH is a flag whether or not to finish
          rainflow cycle counting.  A value of zero or
          'RS_RAINFLOW_CONTINUE' means to continue cycle counting.  A
          non-zero value or 'RS_RAINFLOW_FINISH' means to terminate
          cycle counting.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          One of the following is true.

             * Argument OBJ is a null pointer.

             * Argument SIG is a null pointer and argument SIG_LEN is
               greater than zero and no user-defined signal history
               access function is installed.

             * Cycle counting is finished.

     Non-system error conditions are indicated via the following
     non-zero return values:

     'RS_RAINFLOW_ERROR_STACK_OVERFLOW'
          The stack size exceeds system limits.

     'RS_RAINFLOW_ERROR_CYCLE_OVERFLOW'
          The number of cached cycles exceeds system limits.

 -- Function: int rs_rainflow_finish (rs_rainflow_t *OBJ)
     Finish rainflow cycle counting.

        * Argument OBJ is a pointer to a rainflow cycle counting object.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          One of the following is true.

             * Argument OBJ is a null pointer.

             * Cycle counting is already finished.

     Non-system error conditions are indicated via the following
     non-zero return values:

     'RS_RAINFLOW_ERROR_CYCLE_OVERFLOW'
          The number of cached cycles exceeds system limits.

     Calling this function is equal to ''rs_rainflow' (OBJ, NULL, 0,
     'RS_RAINFLOW_FINISH')'.

 -- Function: size_t rs_rainflow_cycles (rs_rainflow_t *OBJ)
     Return the number of shiftable cycles.

        * Argument OBJ is a pointer to a rainflow cycle counting object.

     Return value is the number of shiftable cycles.  This can be zero.
     In case of an error, the return value is '(size_t) -1' and 'errno'
     is set to describe the error.  The following error conditions are
     defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

 -- Function: int rs_rainflow_shift (rs_rainflow_t *OBJ, double *BUFFER,
          size_t COUNT)
     Shift (consume) the oldest cycles.

        * First argument OBJ is a pointer to a rainflow cycle counting
          object.

        * Second argument BUFFER is a pointer to a buffer where the
          cycles shall be stored.  If argument BUFFER is a null pointer,
          cycles are shifted but not stored.

        * Third argument COUNT is the number of cycles to be shifted.

     The caller is responsible for providing a large enough buffer.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

     'EAGAIN'
          There are not enough cycles available.

 -- Function: double * rs_rainflow_capture (rs_rainflow_t *OBJ)
     Return the cycle counting sequence.

        * Argument OBJ is a pointer to a rainflow cycle counting object.

     Return value is a pointer to the cycle counting sequence, i.e.  a
     block of memory.  The memory block is allocated with the configured
     memory allocation function and the caller is responsible for
     freeing the memory block with the appropriate procedure.  When this
     function succeeds, any call to the 'rs_rainflow_cycles' function
     will return zero.  Thus, you have to determine the number of cycles
     _before_ calling 'rs_rainflow_capture'.

     In case of an error, the return value is a null pointer and 'errno'
     is set to describe the error.  The following error conditions are
     defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

     'EBUSY'
          Cycle counting is not finished.

 -- Function: int rs_rainflow_set_length (rs_rainflow_t *OBJ,
          size_t LEN, size_t ADD)
     Provide hints for memory allocation.

     The default is to infer internal buffer sizes from the number of
     elements in the signal history.

        * First argument OBJ is a pointer to a rainflow cycle counting
          object.

        * Second argument LEN is the initial number of elements.  A
          value of zero means to infer this number from the signal
          length.

        * Third argument ADD is the number of elements to be added iff a
          buffer has to grow.  A value of zero means to infer this
          number from the value of argument LEN.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

     'EBUSY'
          Cycle counting has already started.

 -- Function: int rs_rainflow_set_signal_type (rs_rainflow_t *OBJ,
          int TYPE)
     Customise the array element type.

     The default is a double precision floating-point number.

        * First argument OBJ is a pointer to a rainflow cycle counting
          object.

        * Second argument TYPE is the array element type.  Value should
          be one of the predefined array element types (*note Array
          Element Types::, for a complete list).

     When you call this function, it is expected that the signal history
     is an array with elements of the specified type and that the array
     elements can be accessed sequentially.

     You can specify the predefined array element type
     'RS_RAINFLOW_TYPE_UNKNOWN' to clear any assumption about how signal
     values are stored in the signal history.  See function
     'rs_rainflow_set_read_signals' for how to install a user-defined
     signal history access function.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          One of the following is true.

             * Argument OBJ is a null pointer.

             * Argument TYPE is not one of the predefined array element
               types.

 -- Function: int rs_rainflow_set_read_signals (rs_rainflow_t *OBJ,
          size_t (*FUN) (void *, double *, size_t), size_t INCR)
     Customise the signal history access function.

        * First argument OBJ is a pointer to a rainflow cycle counting
          object.

        * Second argument FUN is the address of a function with three
          arguments.

             - First argument is a pointer to the signal history.  See
               function 'rs_rainflow' for more details.

             - Second argument is a pointer to a signal value buffer.

             - Third argument is the number of signal values to be
               copied.

          Return value is the actual number of signal values copied.  A
          value of zero means that the end of the signal history is
          reached.

          It is guaranteed that the signal value buffer can store the
          requested number of signal values.

        * Third argument INCR is the signal history address increment.
          A value of zero means to not increment the pointer to the
          signal history after copying signal values.  Otherwise, the
          pointer to the signal history is incremented INCR times the
          number of signal values copied.

     When you call this function, you are responsible for converting
     signal values from the signal history to double precision
     floating-point numbers.  This function replaces the built-in signal
     history access function installed by the
     'rs_rainflow_set_signal_type' function.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          One of the following is true.

             * Argument OBJ is a null pointer.

             * Argument FUN is a null pointer and argument INCR is
               greater than zero.

 -- Function: int rs_rainflow_set_shift_cycle (rs_rainflow_t *OBJ,
          void (*FUN) (void *, double const *), void *ARG)
     Customise the cycle shift function.

     Default is to cache shifted cycles.

        * First argument OBJ is a pointer to a rainflow cycle counting
          object.

        * Second argument FUN is the address of a function with two
          arguments.

             - First argument is the value of the ARG argument.

             - Second argument is a pointer to the cycle.

        * Third argument ARG is the first argument of the cycle shift
          function FUN.

     The FUN function will be called when a cycle can be added to the
     cycle counting sequence.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          One of the following is true.

             * Argument OBJ is a null pointer.

             * Argument FUN is a null pointer and argument ARG is not a
               null pointer.

 -- Function: int rs_rainflow_set_signal_label (rs_rainflow_t *OBJ,
          int LABEL)
     Define whether or not to enable signal labels.

     Signal labels are either implicit or explicit.  If no user-defined
     signal history access function is defined, implicit signal labels
     are in effect.  Implicit signal labels start with the number
     defined by the 'rs_rainflow_set_signal_index' function and
     increment by one for each new signal value.  If a user-defined
     signal history access function is defined and signal labels are
     enabled, the signal labels have to be provided by the user-defined
     signal history access function.

        * First argument OBJ is a pointer to a rainflow cycle counting
          object.

        * If second argument LABEL is non-zero, enable signal labels
          cycles.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

 -- Function: int rs_rainflow_set_signal_index (rs_rainflow_t *OBJ,
          double INDEX)
     To be written.

 -- Function: int rs_rainflow_set_merge_cycles (rs_rainflow_t *OBJ,
          int MERGE)
     Define whether or not to merge similar consecutive cycles.

     Cycles are similar if the signal amplitude and mean value are
     equal.  If cycle merging is enabled, similar consecutive cycles are
     merged by adding the individual cycle counts.  Cycle merging is
     enabled by default.

        * First argument OBJ is a pointer to a rainflow cycle counting
          object.

        * If second argument MERGE is non-zero, enable merging of
          similar consecutive cycles.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

     'EBUSY'
          Cycle counting has already started.

 -- Function: int rs_rainflow_set_cycle_style (rs_rainflow_t *OBJ,
          int STYLE)
     Change the cycle representation.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          One of the following is true.

             * Argument OBJ is a null pointer.

             * Argument STYLE is an invalid cycle representation.

     'EBUSY'
          Cycle counting has already started.

 -- Function: int rs_rainflow_set_cycle_sign (rs_rainflow_t *OBJ,
          int FLAG)
     Enable or disable signed cycle representation.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          One of the following is true.

             * Argument OBJ is a null pointer.

     'EBUSY'
          Cycle counting has already started.

 -- Function: int rs_rainflow_sort (rs_rainflow_t *OBJ,
          int (*COMPARE) (void const *, void const *))
     Sort the cached cycles.

     Since sorting destroys the order of the cycle counting sequence,
     unconditionally merge similar cycles, too.  See function
     'rs_rainflow_set_merge_cycles' for more details.

        * First argument OBJ is a pointer to a rainflow cycle counting
          object.

        * Second argument COMPARE is a comparison function.  Default is
          'rs_rainflow_compare_descending'.  *Note Comparison
          Functions::, for more predefined comparison functions.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

 -- Function: int rs_rainflow_sort_cycles (double *BUFFER, size_t COUNT,
          int (*COMPARE) (void const *, void const *))

 -- Function: int rs_rainflow_merge_cycles (double *BUFFER,
          size_t *COUNT, int (*COMPARE) (void const *, void const *))

 -- Function: int rs_rainflow_compare_ascending (void const *LEFT,
          void const *RIGHT)
     Compare two cycles in ascending order.

     Cycles are first compared by the signal amplitude.  If the signal
     amplitude is equal, then the cycles are compared by the mean value.

        * First argument LEFT is the address of a cycle.

        * Second argument RIGHT is the address of a cycle.

 -- Function: int rs_rainflow_compare_descending (void const *LEFT,
          void const *RIGHT)
     Compare two cycles in descending order.

     Cycles are first compared by the signal amplitude.  If the signal
     amplitude is equal, then the cycles are compared by the mean value.

        * First argument LEFT is the address of a cycle.

        * Second argument RIGHT is the address of a cycle.

 -- Function: rs_rainflow_matrix_t * rs_rainflow_matrix_new (void)
     Create a rainflow matrix object.

     Return value is a pointer to a new rainflow matrix object.  In case
     of an error, a null pointer is returned and 'errno' is set to
     describe the error.

 -- Function: void rs_rainflow_matrix_delete (rs_rainflow_matrix_t *OBJ)
     Delete a rainflow matrix object.

        * Argument OBJ is a pointer to a rainflow matrix object.  It is
          no error if argument OBJ is a null pointer.

     Deleting a rainflow matrix object means to unconditionally return
     any allocated memory back to the system including the object
     itself.  After that, all references to the rainflow matrix object
     are void.

 -- Function: int rs_rainflow_matrix_add (rs_rainflow_matrix_t *OBJ,
          double const *CYCLE)
     Add the cycle count of a cycle to the rainflow matrix.

        * First argument OBJ is a pointer to a rainflow matrix object.

        * Second argument CYCLE is a pointer to a cycle.

     The cycle representation of CYCLE, i.e.  the first and second
     element, should be discretised according to the desired bin edges
     of the rainflow matrix.  Third element of CYCLE is the cycle count.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ or CYCLE is a null pointer.

     'EDOM'
          The first or second element of CYCLE is not-a-number.

     'ERANGE'
          The third element of CYCLE is not-a-number or less than zero.

 -- Function: int rs_rainflow_matrix_add3 (rs_rainflow_matrix_t *OBJ,
          double FIRST, double SECOND, double COUNT)
     Add the cycle count of a cycle to the rainflow matrix.

        * First argument OBJ is a pointer to a rainflow matrix object.

        * Second argument FIRST is the index of the first dimension of
          the rainflow matrix.  This is usually the first element of the
          cycle representation.

        * Third argument SECOND is the index of the second dimension of
          the rainflow matrix.  This is usually the second element of
          the cycle representation.

        * Fourth argument COUNT is the cycle count.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

     'EDOM'
          Argument FIRST or SECOND is not-a-number.

     'ERANGE'
          Argument COUNT is not-a-number or less than zero.

 -- Function: double rs_rainflow_matrix_get (rs_rainflow_matrix_t *OBJ,
          double const *CYCLE)
     Get the cycle count of a cycle from the rainflow matrix.

        * First argument OBJ is a pointer to a rainflow matrix object.

        * Second argument CYCLE is a pointer to a cycle.

     The cycle representation of CYCLE, i.e.  the first and second
     element, should be discretised according to the desired bin edges
     of the rainflow matrix.

     Return value is the cycle count.  In case of an error, the return
     value is not-a-number and 'errno' is set to describe the error.
     The following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ or CYCLE is a null pointer.

     'EDOM'
          The first or second element of CYCLE is not-a-number.

 -- Function: double rs_rainflow_matrix_get2 (rs_rainflow_matrix_t *OBJ,
          double FIRST, double SECOND)
     Get the cycle count of a cycle from the rainflow matrix.

        * First argument OBJ is a pointer to a rainflow matrix object.

        * Second argument FIRST is the index of the first dimension of
          the rainflow matrix.  This is usually the first element of the
          cycle representation.

        * Third argument SECOND is the index of the second dimension of
          the rainflow matrix.  This is usually the second element of
          the cycle representation.

     Return value is the cycle count.  In case of an error, the return
     value is not-a-number and 'errno' is set to describe the error.
     The following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

     'EDOM'
          Argument FIRST or SECOND is not-a-number.

 -- Function: int rs_rainflow_matrix_limits (rs_rainflow_matrix_t *OBJ,
          int DIM, double *MIN, double *MAX)
     Get the lower and upper bound of a rainflow matrix dimension.

        * First argument OBJ is a pointer to a rainflow matrix object.

        * Second argument DIM is the rainflow matrix dimension.  Value
          is either zero, i.e.  the first dimension, or 1, i.e.  the
          second dimension.

        * Third argument MIN is the address where to store the value of
          the lower bound.  No value will be stored if MIN is a null
          pointer.

        * Fourth argument MAX is the address where to store the value of
          the upper bound.  No value will be stored if MAX is a null
          pointer.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

     'ERANGE'
          The rainflow matrix is empty.

 -- Function: size_t rs_rainflow_matrix_non_zero
          (rs_rainflow_matrix_t *OBJ)
     Return the number of non-zero elements of a rainflow matrix.

        * Argument OBJ is a pointer to a rainflow matrix object.

     Return value is zero on success.  In case of an error, the return
     value is -1 and 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ is a null pointer.

 -- Function: void rs_rainflow_matrix_map (rs_rainflow_matrix_t *OBJ,
          void (*FUN) (void *, double const *), void *ARG)
     Apply a function on any non-zero element of a rainflow matrix.

        * First argument OBJ is a pointer to a rainflow matrix object.

        * Second argument FUN is the address of a function with two
          arguments.

             - First argument is the value of the ARG argument.

             - Second argument is a pointer to the cycle.

        * Third argument ARG is the first argument of the function FUN.

     In case of an error, 'errno' is set to describe the error.  The
     following error conditions are defined for this function:

     'EINVAL'
          Argument OBJ or FUN is a null pointer.

 -- Function: void rs_rainflow_round_amplitude_mean (double *CYCLE,
          double SCALE)
 -- Function: void rs_rainflow_round_range_mean (double *CYCLE,
          double SCALE)
 -- Function: void rs_rainflow_round_from_to (double *CYCLE,
          double SCALE)
     Round the signal values of CYCLE to a multiple of SCALE.

        * First argument CYCLE is the address of a cycle.

        * Second argument SCALE is the rounding scale factor.  Value has
          to be a positive number.

     The cycle representation of CYCLE is modified in-place.

     'rs_rainflow_round_amplitude_mean'
          Round an amplitude/mean cycle representation.

     'rs_rainflow_round_range_mean'
          Round a range/mean cycle representation.

     'rs_rainflow_round_from_to'
          Round a from/to cycle representation.

 -- Function: double rs_rainflow_round_up (double NUMBER, double SCALE)
 -- Function: double rs_rainflow_round_down (double NUMBER,
          double SCALE)
 -- Function: double rs_rainflow_round_zero (double NUMBER,
          double SCALE)
 -- Function: double rs_rainflow_round_inf (double NUMBER, double SCALE)
     Round NUMBER to a multiple of SCALE.

        * First argument NUMBER is a number.

        * Second argument SCALE is the rounding scale factor.  Value has
          to be a positive number.

     Return value is the rounded number.

     'rs_rainflow_round_up'
          Round towards plus infinity.

     'rs_rainflow_round_down'
          Round towards minus infinity.

     'rs_rainflow_round_zero'
          Round towards zero (away from infinity).

     'rs_rainflow_round_inf'
          Round away from zero (towards infinity).


File: rs-rainflow.info,  Node: Enumerated Constants,  Prev: Functions,  Up: API Reference

3.3 Enumerated Constants
========================

* Menu:

* Array Element Types::
* Extended Error Codes::


File: rs-rainflow.info,  Node: Array Element Types,  Next: Extended Error Codes,  Prev: Enumerated Constants,  Up: Enumerated Constants

3.3.1 Array Element Types
-------------------------

 -- Constant: int RS_RAINFLOW_TYPE_UNKNOWN
 -- Constant: int RS_RAINFLOW_TYPE_DOUBLE
 -- Constant: int RS_RAINFLOW_TYPE_FLOAT
 -- Constant: int RS_RAINFLOW_TYPE_CHAR
 -- Constant: int RS_RAINFLOW_TYPE_UCHAR
 -- Constant: int RS_RAINFLOW_TYPE_SHORT
 -- Constant: int RS_RAINFLOW_TYPE_USHORT
 -- Constant: int RS_RAINFLOW_TYPE_INT
 -- Constant: int RS_RAINFLOW_TYPE_UINT
 -- Constant: int RS_RAINFLOW_TYPE_LONG
 -- Constant: int RS_RAINFLOW_TYPE_ULONG
 -- Constant: int RS_RAINFLOW_TYPE_INT8_T
 -- Constant: int RS_RAINFLOW_TYPE_UINT8_T
 -- Constant: int RS_RAINFLOW_TYPE_INT16_T
 -- Constant: int RS_RAINFLOW_TYPE_UINT16_T
 -- Constant: int RS_RAINFLOW_TYPE_INT32_T
 -- Constant: int RS_RAINFLOW_TYPE_UINT32_T
 -- Constant: int RS_RAINFLOW_TYPE_INT64_T
 -- Constant: int RS_RAINFLOW_TYPE_UINT64_T
     The predefined array element types.  See function
     'rs_rainflow_set_signal_type'.  The array element type
     'RS_RAINFLOW_TYPE_CHAR' specifies a signed character, that is
     'signed char' in C.


File: rs-rainflow.info,  Node: Extended Error Codes,  Prev: Array Element Types,  Up: Enumerated Constants

3.3.2 Extended Error Codes
--------------------------

 -- Constant: int RS_RAINFLOW_ERROR_STACK_OVERFLOW
     The stack size exceeds system limits.

 -- Constant: int RS_RAINFLOW_ERROR_CYCLE_OVERFLOW
     The number of cached cycles exceeds system limits.


File: rs-rainflow.info,  Node: Examples,  Next: Symbol Index,  Prev: API Reference,  Up: Top

4 Examples
**********

The source code archive contains several examples for how to use the
'rs-rainflow' library.

* Menu:

* Basic Example::
* Using Call-back Functions::
* Reservoir Cycle Counting::
* Auxiliary Procedures::


File: rs-rainflow.info,  Node: Basic Example,  Next: Using Call-back Functions,  Prev: Examples,  Up: Examples

4.1 Basic Example
=================

The first example shows a naive usage of the 'rs-rainflow' library.

     int
     main (void)
     {
       rs_rainflow_t *obj;
       size_t buf_len;
       double *buf;

       /* Maximum number of signal values to be read.  */
       buf_len = 1000;

       /* Signal value buffer.  */
       buf = calloc (buf_len, sizeof (double));
       if (buf == NULL)
         abort ();

       /* Create rainflow cycle counting object.  */
       obj = rs_rainflow_new ();
       if (obj == NULL)
         abort ();

       /* Process signal values.  */
       while (1)
         {
           size_t count;

           count = read_from_stream (stdin, buf, buf_len);
           if (count == 0)
             break;

           if (rs_rainflow (obj, buf, count, RS_RAINFLOW_CONTINUE) != 0)
             abort ();
         }

       if (rs_rainflow_finish (obj) != 0)
         abort ();

       /* Print cycle counting sequence.  */
       print_cycles (stdout, obj);

       /* Destroy object.  */
       rs_rainflow_delete (obj);

       return 0;
     }


File: rs-rainflow.info,  Node: Using Call-back Functions,  Next: Reservoir Cycle Counting,  Prev: Basic Example,  Up: Examples

4.2 Using Call-back Functions
=============================

This program does the same as the previous example, but much more memory
efficient.

     int
     main (void)
     {
       rs_rainflow_t *obj;

       /* Create rainflow cycle counting object.  */
       obj = rs_rainflow_new ();
       if (obj == NULL)
         abort ();

       /* Install call-back functions.

          Copy signal values from the signal history (a stream) to the signal
          buffer of the rainflow cycle counting object.  Do not increment the
          signal history pointer.  */
       rs_rainflow_set_read_signals (obj, (void *) read_from_stream, 0);

       /* Print cycle counting sequence to 'stdout'.  */
       rs_rainflow_set_shift_cycle (obj, (void *) print_cycle, stdout);

       /* Perform rainflow cycle counting.

          Read signal values from 'stdin' until end of file.  */
       if (rs_rainflow (obj, stdin, (size_t) -1, RS_RAINFLOW_FINISH) != 0)
         abort ();

       /* Destroy rainflow cycle counting object.  */
       rs_rainflow_delete (obj);

       return 0;
     }


File: rs-rainflow.info,  Node: Reservoir Cycle Counting,  Next: Auxiliary Procedures,  Prev: Using Call-back Functions,  Up: Examples

4.3 Reservoir Cycle Counting
============================

This example shows how to implement reservoir cycle counting on top of
rainflow cycle counting.

Reservoir counting creates the same result as rainflow counting iff the
signal history starts and ends with the absolute signal maximum.
Otherwise, reservoir counting is slightly more conservative than
rainflow counting.  Another property of reservoir counting is that the
resulting cycle counting sequence only contains full cycles.  However,
you have to know the full signal history in advance so that you can find
the global maximum.

     void
     reservoir (rs_rainflow_t *obj, double *sig_buf, size_t sig_len)
     {
       size_t j, k;

       /* Locate global maximum of the signal history.  */
       k = 0;

       for (j = 1; j < sig_len; ++j)
         {
           if (sig_buf[j] > sig_buf[k])
             k = j;
         }

       /* Rearrange the signal history so that it starts and ends
          with the global maximum.  */
       if (rs_rainflow (obj, sig_buf + k, sig_len - k, RS_RAINFLOW_CONTINUE) != 0)
         abort ();

       if (rs_rainflow (obj, sig_buf, k + 1, RS_RAINFLOW_FINISH) != 0)
         abort ();
     }


File: rs-rainflow.info,  Node: Auxiliary Procedures,  Prev: Reservoir Cycle Counting,  Up: Examples

4.4 Auxiliary Procedures
========================

Here are three auxiliary procedures for the examples.  The first
function reads a number of floating-point numbers from a stream.

     size_t
     read_from_stream (FILE *stream, double *buffer, size_t count)
     {
       size_t n;

       for (n = 0; count > 0; --count, ++buffer, ++n)
         {
           if (fscanf (stream, "%lf", buffer) != 1)
             break;
         }

       return n;
     }

The next function prints a single cycle to a stream.

     void
     print_cycle (FILE *stream, double const *cycle)
     {
       /* Print cycle count as the number of full cycles.  */
       fprintf (stream, "%.5G;%.5G;%.5G\n", cycle[0], cycle[1], cycle[2] / 2.0);
     }

The last function prints the whole cycle counting sequence of a
'rs-rainflow' object.

     void
     print_cycles (FILE *stream, rs_rainflow_t *obj)
     {
       double cycle[5];
       size_t n;

       for (n = rs_rainflow_cycles (obj); n > 0; --n)
         {
           /* Consume oldest cycle.  */
           rs_rainflow_shift (obj, cycle, 1);
           print_cycle (stream, cycle);
         }
     }


File: rs-rainflow.info,  Node: Symbol Index,  Next: Concept Index,  Prev: Examples,  Up: Top

Symbol Index
************

 [index ]
* Menu:

* rs_rainflow:                           Functions.           (line  77)
* rs_rainflow_alloc:                     Functions.           (line  13)
* rs_rainflow_capture:                   Functions.           (line 187)
* rs_rainflow_compare_ascending:         Functions.           (line 485)
* rs_rainflow_compare_descending:        Functions.           (line 496)
* RS_RAINFLOW_CONTINUE:                  Functions.           (line  92)
* rs_rainflow_cycles:                    Functions.           (line 148)
* rs_rainflow_delete:                    Functions.           (line  48)
* RS_RAINFLOW_ERROR_CYCLE_OVERFLOW:      Extended Error Codes.
                                                              (line   9)
* RS_RAINFLOW_ERROR_STACK_OVERFLOW:      Extended Error Codes.
                                                              (line   6)
* RS_RAINFLOW_FINISH:                    Functions.           (line  92)
* rs_rainflow_finish:                    Functions.           (line 123)
* rs_rainflow_matrix_add:                Functions.           (line 525)
* rs_rainflow_matrix_add3:               Functions.           (line 550)
* rs_rainflow_matrix_delete:             Functions.           (line 514)
* rs_rainflow_matrix_get:                Functions.           (line 579)
* rs_rainflow_matrix_get2:               Functions.           (line 601)
* rs_rainflow_matrix_limits:             Functions.           (line 626)
* rs_rainflow_matrix_map:                Functions.           (line 668)
* rs_rainflow_matrix_new:                Functions.           (line 507)
* rs_rainflow_matrix_non_zero:           Functions.           (line 654)
* rs_rainflow_matrix_t:                  Data Types.          (line  12)
* rs_rainflow_merge_cycles:              Functions.           (line 481)
* rs_rainflow_new:                       Functions.           (line   6)
* rs_rainflow_reset:                     Functions.           (line  59)
* rs_rainflow_round_amplitude_mean:      Functions.           (line 689)
* rs_rainflow_round_down:                Functions.           (line 716)
* rs_rainflow_round_from_to:             Functions.           (line 694)
* rs_rainflow_round_inf:                 Functions.           (line 720)
* rs_rainflow_round_range_mean:          Functions.           (line 691)
* rs_rainflow_round_up:                  Functions.           (line 715)
* rs_rainflow_round_zero:                Functions.           (line 718)
* rs_rainflow_set_cycle_sign:            Functions.           (line 436)
* rs_rainflow_set_cycle_style:           Functions.           (line 417)
* rs_rainflow_set_length:                Functions.           (line 210)
* rs_rainflow_set_merge_cycles:          Functions.           (line 391)
* rs_rainflow_set_read_signals:          Functions.           (line 275)
* rs_rainflow_set_shift_cycle:           Functions.           (line 325)
* rs_rainflow_set_signal_index:          Functions.           (line 387)
* rs_rainflow_set_signal_label:          Functions.           (line 359)
* rs_rainflow_set_signal_type:           Functions.           (line 238)
* rs_rainflow_shift:                     Functions.           (line 161)
* rs_rainflow_sort:                      Functions.           (line 453)
* rs_rainflow_sort_cycles:               Functions.           (line 477)
* rs_rainflow_t:                         Data Types.          (line   6)
* RS_RAINFLOW_TYPE_CHAR:                 Array Element Types. (line   9)
* RS_RAINFLOW_TYPE_DOUBLE:               Array Element Types. (line   7)
* RS_RAINFLOW_TYPE_FLOAT:                Array Element Types. (line   8)
* RS_RAINFLOW_TYPE_INT:                  Array Element Types. (line  13)
* RS_RAINFLOW_TYPE_INT16_T:              Array Element Types. (line  19)
* RS_RAINFLOW_TYPE_INT32_T:              Array Element Types. (line  21)
* RS_RAINFLOW_TYPE_INT64_T:              Array Element Types. (line  23)
* RS_RAINFLOW_TYPE_INT8_T:               Array Element Types. (line  17)
* RS_RAINFLOW_TYPE_LONG:                 Array Element Types. (line  15)
* RS_RAINFLOW_TYPE_SHORT:                Array Element Types. (line  11)
* RS_RAINFLOW_TYPE_UCHAR:                Array Element Types. (line  10)
* RS_RAINFLOW_TYPE_UINT:                 Array Element Types. (line  14)
* RS_RAINFLOW_TYPE_UINT16_T:             Array Element Types. (line  20)
* RS_RAINFLOW_TYPE_UINT32_T:             Array Element Types. (line  22)
* RS_RAINFLOW_TYPE_UINT64_T:             Array Element Types. (line  24)
* RS_RAINFLOW_TYPE_UINT8_T:              Array Element Types. (line  18)
* RS_RAINFLOW_TYPE_ULONG:                Array Element Types. (line  16)
* RS_RAINFLOW_TYPE_UNKNOWN:              Array Element Types. (line   6)
* RS_RAINFLOW_TYPE_USHORT:               Array Element Types. (line  12)


File: rs-rainflow.info,  Node: Concept Index,  Next: References,  Prev: Symbol Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* allocation, memory:                    Instantiation.        (line 17)
* alternative memory manager:            Instantiation.        (line 17)
* amplitude, signal:                     Introduction.         (line  6)
* capture cycle counting sequence:       Execution.            (line 27)
* constructor:                           Instantiation.        (line  6)
* context:                               Instantiation.        (line 10)
* creating an object:                    Instantiation.        (line  6)
* cycle count:                           Introduction.         (line  6)
* cycle counting sequence, capture:      Execution.            (line 27)
* cycle counting sequence, length:       Execution.            (line 13)
* cycle counting, finish:                Execution.            (line 18)
* cycle counting, rainflow:              Execution.            (line  6)
* cycle counting, reservoir:             Reservoir Cycle Counting.
                                                               (line  6)
* cycle, mean value:                     Introduction.         (line  6)
* cycle, shift:                          Execution.            (line 14)
* data type:                             Instantiation.        (line 10)
* deleting an object:                    Instantiation.        (line 24)
* destroying an object:                  Instantiation.        (line 24)
* destructor:                            Instantiation.        (line 24)
* finish cycle counting:                 Execution.            (line 18)
* instantiating an object:               Instantiation.        (line  6)
* length of cycle counting sequence:     Execution.            (line 13)
* mean signal value:                     Introduction.         (line  6)
* memory allocation:                     Instantiation.        (line 17)
* memory manager, alternative:           Instantiation.        (line 17)
* object:                                Instantiation.        (line 10)
* object creation:                       Instantiation.        (line  6)
* object deletion:                       Instantiation.        (line 24)
* object reuse:                          Instantiation.        (line 27)
* peak signal value:                     Introduction.         (line  6)
* rainflow cycle counting:               Execution.            (line  6)
* reservoir cycle counting:              Reservoir Cycle Counting.
                                                               (line  6)
* reusing an object:                     Instantiation.        (line 27)
* shift cycle:                           Execution.            (line 14)
* signal amplitude:                      Introduction.         (line  6)
* signal value, peak:                    Introduction.         (line  6)
* signal value, trough:                  Introduction.         (line  6)
* state:                                 Instantiation.        (line 10)
* terminate cycle counting:              Execution.            (line 18)
* trough signal value:                   Introduction.         (line  6)


File: rs-rainflow.info,  Node: References,  Prev: Concept Index,  Up: Top

References
**********

[1]
     ASTM E1049-85: 'Standard Practices for Cycle Counting in Fatigue
     Analysis'.  ASTM International, <http://www.astm.org>.



Tag Table:
Node: Top491
Node: Introduction1034
Node: User's Guide2070
Ref: User's Guide-Footnote-13682
Node: Instantiation3711
Node: Execution4884
Node: Customisation6226
Node: Signal History7121
Ref: Array of Numbers7392
Ref: User-defined Call-back Function7961
Node: Signal Labels8264
Ref: Implicit Signal Labels9305
Ref: Explicit Signal Labels9955
Ref: Signal Labels-Footnote-111318
Node: Cycle Representation11594
Ref: Amplitude/Mean Cycle Representation12437
Ref: Range/Mean Cycle Representation13290
Ref: From/To Cycle Representation13657
Ref: Cycle Representation-Footnote-113921
Node: Merging Cycles14062
Node: Consuming Cycles14913
Node: Sorting Cycles16032
Node: Rainflow Matrix17487
Node: API Reference19719
Node: Data Types19999
Ref: rs_rainflow_t20135
Ref: rs_rainflow_matrix_t20326
Node: Functions20508
Ref: rs_rainflow_new20649
Ref: rs_rainflow_alloc20922
Ref: rs_rainflow_delete22564
Ref: rs_rainflow_reset23044
Ref: rs_rainflow23721
Ref: RS_RAINFLOW_CONTINUE24273
Ref: RS_RAINFLOW_FINISH24273
Ref: rs_rainflow_finish25367
Ref: rs_rainflow_cycles26187
Ref: rs_rainflow_shift26672
Ref: rs_rainflow_capture27547
Ref: rs_rainflow_set_length28489
Ref: rs_rainflow_set_signal_type29486
Ref: rs_rainflow_set_read_signals30839
Ref: rs_rainflow_set_shift_cycle32795
Ref: rs_rainflow_set_signal_label33909
Ref: rs_rainflow_set_signal_index35005
Ref: rs_rainflow_set_merge_cycles35118
Ref: rs_rainflow_set_cycle_style36018
Ref: rs_rainflow_set_cycle_sign36574
Ref: rs_rainflow_sort37075
Ref: rs_rainflow_sort_cycles37949
Ref: rs_rainflow_merge_cycles38078
Ref: Comparison Functions38209
Ref: rs_rainflow_compare_ascending38209
Ref: rs_rainflow_compare_descending38613
Ref: rs_rainflow_matrix_new39019
Ref: rs_rainflow_matrix_delete39291
Ref: rs_rainflow_matrix_add39754
Ref: rs_rainflow_matrix_add340686
Ref: rs_rainflow_matrix_get41747
Ref: rs_rainflow_matrix_get242562
Ref: rs_rainflow_matrix_limits43495
Ref: rs_rainflow_matrix_non_zero44555
Ref: rs_rainflow_matrix_map45031
Ref: rs_rainflow_round_amplitude_mean45785
Ref: rs_rainflow_round_range_mean45785
Ref: rs_rainflow_round_from_to45785
Ref: rs_rainflow_round_up46610
Ref: rs_rainflow_round_down46610
Ref: rs_rainflow_round_zero46610
Ref: rs_rainflow_round_inf46610
Node: Enumerated Constants47465
Node: Array Element Types47668
Ref: RS_RAINFLOW_TYPE_UNKNOWN47860
Ref: RS_RAINFLOW_TYPE_DOUBLE47860
Ref: RS_RAINFLOW_TYPE_FLOAT47860
Ref: RS_RAINFLOW_TYPE_CHAR47860
Ref: RS_RAINFLOW_TYPE_UCHAR47860
Ref: RS_RAINFLOW_TYPE_SHORT47860
Ref: RS_RAINFLOW_TYPE_USHORT47860
Ref: RS_RAINFLOW_TYPE_INT47860
Ref: RS_RAINFLOW_TYPE_UINT47860
Ref: RS_RAINFLOW_TYPE_LONG47860
Ref: RS_RAINFLOW_TYPE_ULONG47860
Ref: RS_RAINFLOW_TYPE_INT8_T47860
Ref: RS_RAINFLOW_TYPE_UINT8_T47860
Ref: RS_RAINFLOW_TYPE_INT16_T47860
Ref: RS_RAINFLOW_TYPE_UINT16_T47860
Ref: RS_RAINFLOW_TYPE_INT32_T47860
Ref: RS_RAINFLOW_TYPE_UINT32_T47860
Ref: RS_RAINFLOW_TYPE_INT64_T47860
Ref: RS_RAINFLOW_TYPE_UINT64_T47860
Node: Extended Error Codes48864
Ref: RS_RAINFLOW_ERROR_STACK_OVERFLOW49029
Ref: RS_RAINFLOW_ERROR_CYCLE_OVERFLOW49124
Node: Examples49232
Node: Basic Example49556
Node: Using Call-back Functions50757
Node: Reservoir Cycle Counting51979
Node: Auxiliary Procedures53317
Node: Symbol Index54564
Node: Concept Index59507
Node: References62710

End Tag Table


Local Variables:
coding: utf-8
End:
